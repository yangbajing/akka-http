# Source 数据流
*Source Streaming*

Akka HTTP supports completing a request with an Akka @apidoc[Source[T, \_]], which makes it possible to easily build
and consume streaming end-to-end APIs which apply back pressure throughout the entire stack.

Akka HTTP 支持使用 @apidoc[Source[T, \_]] 完成请求，这使得轻松构建和使用流式端到端 API 成为可能，该 API 在整个栈中处处应用回压。

It is possible to complete requests with raw @apidoc[Source[ByteString, \_]], however often it is more convenient to
stream on an element-by-element basis, and allow Akka HTTP to handle the rendering internally - for example as a JSON array,
or CSV stream (where each element is followed by a newline).

可以使用原始的 @apidoc[Source[ByteString, \_]] 来完成请求，然而更方便的是基于元素到元素上的流，并允许 Akka HTTP 在内部处理渲染 -
例如作为 JSON 数组或 CSV 流（其中每个元素后面跟着一个新行）。

In the following sections we investigate how to make use of the JSON Streaming infrastructure,
however the general hints apply to any kind of element-by-element streaming you could imagine.

在下面部分中，我们研究如何利用 JSON 数据流基础设施，但是一般的提示适用于你可以想像的任何类型的元素到元素数据流。

# JSON Streaming
**JSON 数据流**

[JSON Streaming](https://en.wikipedia.org/wiki/JSON_Streaming) is a term referring to streaming a (possibly infinite) stream of element as independent JSON
objects as a continuous HTTP request or response. The elements are most often separated using newlines,
however do not have to be. Concatenating elements side-by-side or emitting "very long" JSON array is also another
use case.

[JSON 数据流](https://en.wikipedia.org/wiki/JSON_Streaming) 是一个术语，指将一个（可能无限）流的元素作为独立的 JSON 对象，作为持续的 HTTP 请求或响应数据流。
元素通常使用换行分割，但不必这样。并排连接元素或发出“很长的” JSON 数组也是另一个用例。

In the below examples, we'll be referring to the `Tweet` case class as our model, which is defined as:

在下面的例子中，我们将引用 `Tweet` case 类为我们的模型，它的定义为：

Scala
:   @@snip [JsonStreamingExamplesSpec.scala]($test$/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala) { #tweet-model }

Java
:   @@snip [JsonStreamingExamplesTest.java]($test$/java/docs/http/javadsl/server/JsonStreamingExamplesTest.java) { #tweet-model }

@@@ div { .group-scala }

And as always with `spray-json`, we provide our marshaller and unmarshaller instances as implicit values using the `jsonFormat##`
method to generate them statically:

像往常使用 `spary-json` 一样，我们使用 `jsonFormat##` 方法将我们的编组和解组实例作为隐式值来静态生成：

Scala
:   @@snip [JsonStreamingExamplesSpec.scala]($test$/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala) { #tweet-format }

@@@

## Responding with JSON Streams
**使用 JSON 流回应**

In this example we implement an API representing an infinite stream of tweets, very much like Twitter's [Streaming API](https://dev.twitter.com/streaming/overview).

在这个例子里，我们实现一个 API 来代表 tweets 的一个无限流，非常像 Twitter 的 [流式 API](https://dev.twitter.com/streaming/overview) 。

@@@ div { .group-scala }

Firstly, we'll need to get some additional marshalling infrastructure set up, that is able to marshal to and from an
Akka Streams @apidoc[Source[T, \_]]. One such trait, containing the needed marshallers is `SprayJsonSupport`, which uses
`spray-json` (a high performance JSON parser library), and is shipped as part of Akka HTTP in the
`akka-http-spray-json` module.

首先，我们将需要获得一些额外的编组基础设施，它能够编组/解组 Akka 流 @apidoc[Source[T, \_]] 。
其中一个包含所需编组器的 trait 是 `SparyJsonSupport`，它使用 `spary-json`（高性能 JSON 解析库），
并作为 Akka HTTP 的一部分在 `akka-http-spary-json` 模块里。

Once the general infrastructure is prepared, we import our model's marshallers, generated by `spray-json` (Step 1)
and enable JSON Streaming by making an implicit @apidoc[EntityStreamingSupport] instance available (Step 2).
Akka HTTP pre-packages JSON and CSV entity streaming support, however it is simple to add your own, in case you'd
like to stream a different content type (for example plists or protobuf).

一旦普通基础设施已准备好，我们导入我们模型的编组，它由 `spar-json` 生成（步骤 1），并通过生成隐式 @apidoc[EntityStreamingSupport] 实例来启用数据流（步骤 2）。
Akka HTTP 预先打包了 JSON 和 CSV 实体数据流支持，但是添加自己的数据流支持很简单，这种情况下你想流式处理不同的内容类型（例如：plists 或者 protobuf）。
@@@

@@@ div { .group-java }

Firstly, we'll need to get some additional marshalling infrastructure set up, that is able to marshal to and from an
Akka Streams @apidoc[Source[T, ?]]. Here we'll use the `Jackson` helper class from `akka-http-jackson` (a separate library
that you should add as a dependency if you want to use Jackson with Akka HTTP).

First we enable JSON Streaming by making an implicit @apidoc[EntityStreamingSupport] instance available (Step 1).

The default mode of rendering a @apidoc[Source] is to represent it as an JSON Array. If you want to change this representation
for example to use Twitter style new-line separated JSON objects, you can do so by configuring the support trait accordingly.

In Step 1.1. we demonstrate how to configure the rendering to be new-line separated, and also how parallel marshalling
can be applied. We configure the Support object to render the JSON as series of new-line separated JSON objects,
simply by appending a ByteString consisting of a single new-line character to each ByteString in the stream. Although this format is *not* valid JSON, it is pretty popular since parsing it is relatively
simple - clients need only to find the new-lines and apply JSON unmarshalling for an entire line of JSON.


@@@

The final step is simply completing a request using a Source of tweets, as simple as that:

最后一步是使用 tweets 的 Source 来简单的完成请求，就像这么简单：

Scala
:   @@snip [JsonStreamingExamplesSpec.scala]($test$/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala) { #spray-json-response-streaming }

Java
:   @@snip [JsonStreamingExamplesTest.java]($test$/java/docs/http/javadsl/server/JsonStreamingExamplesTest.java) { #response-streaming }

The reason the @apidoc[EntityStreamingSupport] has to be enabled explicitly is that one might want to configure how the
stream should be rendered. We'll discuss this in depth in the next section though.

必须明确启用 @apidoc[EntityStreamingSupport] 的原因是，可能希望配置流怎样被渲染。我们将在下一节深入讨论这个话题。

@@@ div { .group-scala }

### Customising response rendering mode
**定制响应渲染模式**

Since it is not always possible to directly and confidently answer the question of how a stream of `T` should look on
the wire, the @apidoc[EntityStreamingSupport] traits come into play and allow fine-tuning the stream's rendered representation.

因为不总是可能直接并有把握地回答如何看待线上 `T` 流的问题， @apidoc[EntityStreamingSupport] trait 开始发挥作用，并且可以微调流的渲染表现。

For example, in case of JSON Streaming, there isn't really one standard about rendering the response. Some APIs prefer
to render multiple JSON objects in a line-by-line fashion (Twitter's streaming APIs for example), while others simply return
very large arrays, which could be streamed as well.

例如，在 JSON 数据流的情况中，关于渲染响应没有事实标准。有些 API 更喜欢一行一行的渲染多个 JSON 对象（例如 Twitter 的流式 API），
而另一些简单返回一个很大的数组，这些数组也可以流式处理。

Akka defaults to the second one (streaming a JSON Array), as it is correct JSON and clients not expecting
a streaming API would still be able to consume it in a naive way if they'd want to.

Akka 默认第二种方式（流式的 JSON 数组），因为它是正确的 JSON，并且如果客户端希望的话，它们不假定流式 API，仍然能够以一种天真的方式使用它。 

The line-by-line approach however is also pretty popular even though it is not valid JSON. Its simplicity for
client-side parsing is a strong point in case to pick this format for your Streaming APIs.
Below we demonstrate how to reconfigure the support trait to render the JSON line-by-line.

然而，按行处理的方法也非常流行，尽管它们是无效的 JSON。它对于客户端解析的简单性是为流式 API 挑选这种格式的一个优点。
下面我们演示怎样重新配置支持 trait 来按行渲染 JSON。  

Scala
:   @@snip [JsonStreamingExamplesSpec.scala]($test$/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala) { #line-by-line-json-response-streaming }

Another interesting feature is parallel marshalling. Since marshalling can potentially take much time,
it is possible to marshal multiple elements of the stream in parallel. This is simply a configuration
option on @apidoc[EntityStreamingSupport] and is configurable like this:

另一个有趣的特性是并行编组。因为编组有可能花很多时间，所以可以并行编组流的多个元素。这是 @apidoc[EntityStreamingSupport] 的一个简单配置选项，配置像这样：

Scala
:   @@snip [JsonStreamingExamplesSpec.scala]($test$/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala) { #async-rendering }

The above shown mode preserves ordering of the Source's elements, which may sometimes be a required property,
for example when streaming a strictly ordered dataset. Sometimes the concept of strict order does not apply to the
data being streamed, though, which allows us to exploit this property and use an `unordered` rendering.

上面显示的模式保持 Source 的元素的顺序，这有时是必须的属性，比如当流处理一个严格有序的数据库。有时严格有序的概念不适用于正在流式传输的数据，
这时，允许我们利用这个属性并使用 `无序` 渲染。

This `unordered` rendering can be enabled via a configuration option as shown below. Effectively, this allows Akka HTTP's marshalling infrastructure to concurrently marshall up to as many elements as defined in `parallelism` and emit the first one which is marshalled into the @apidoc[HttpResponse]:

`无序` 渲染可以通过下面所示的配置选项启用。实际上，这允许 Akka HTTP 的编组基础设施并发的编组直到 `parallelism` 定义的尽可能多的元素，并（同时）发出第一个被编组的元素到 @apidoc[HttpResponse] ：

Scala
:   @@snip [JsonStreamingExamplesSpec.scala]($test$/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala) { #async-unordered-rendering }

This allows us to _potentially_ render elements faster into the HttpResponse, since it can avoid "head of line blocking",
in case one element in front of the stream takes a long time to marshall, yet others after it are very quick to marshall.

这允许我们 *潜在地* 更快的将元素渲染进 `HttpResponse` 中，因它这可以避免“行首阻塞”，以防止流前的元素花很长时间编组，而后面的其它元素则非常快的编组。

@@@

## Consuming JSON Streaming uploads
**消费上传的 JSON 数据流**

Sometimes a client sends a streaming request. For example, an embedded device initiated a connection with
the server and is feeding it with one line of measurement data.

有时客户端发送流式请求。例如：嵌入式设备初始化发起与服务器的连接，并向服务器提供一行测量数据。 

In this example, we want to consume this data in a streaming fashion from the request entity and also apply
back pressure to the underlying TCP connection should the server be unable to cope with the rate of incoming data. Back pressure
is automatically applied thanks to @extref[Akka Streams](akka-docs:scala/stream/index.html).

这个例子中，我们希望以流式的方式消费请求实体的数据，并在服务器无法处理传入数据的速率时应用回压到底层的 TCP 连接。 
回压是自动应用的，感谢 @extref[Akka Streams](akka-docs:scala/stream/index.html) 。

Scala
:   @@snip [JsonStreamingExamplesSpec.scala]($test$/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala) { #measurement-model #measurement-format }

Java
:   @@snip [JsonStreamingExamplesTest.java]($test$/java/docs/http/javadsl/server/JsonStreamingExamplesTest.java) { #measurement-model #measurement-format }


Scala
:   @@snip [JsonStreamingExamplesSpec.scala]($test$/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala) { #spray-json-request-streaming }

Java
:   @@snip [JsonStreamingExamplesTest.java]($test$/java/docs/http/javadsl/server/JsonStreamingExamplesTest.java) { #incoming-request-streaming }


## Simple CSV streaming example
**简单 CSV 数据流示例**

Akka HTTP provides another @apidoc[EntityStreamingSupport] out of the box, namely `csv` (comma-separated values).
For completeness, we demonstrate its usage in the snippet below. As you'll notice, switching between streaming
modes is fairly simple: You only have to make sure that an implicit @apidoc[Marshaller] of the requested type is available
and that the streaming support operates on the same `Content-Type` as the rendered values. Otherwise, you'll see
an error during runtime that the marshaller did not expose the expected content type and thus we can't render
the streaming response).

Akka HTTP 提供了另一个开箱即用的 @apidoc[EntityStreamingSupport] ，既 `csv`（逗号-分隔的值）。为了完整起见，
我们在下面代码片段里演示它的使用方法。正如你注意到的，切换流模式相当简单：你只需要确保请求类型的隐式 @apidoc[Marshaller] 可用，
并且流支持操作与渲染值相同的 `Content-Type`。否则，你将在运行期看到一个错误：编组未暴露预期的内容类型，因此我们不能渲染流式响应。

Scala
:   @@snip [JsonStreamingExamplesSpec.scala]($test$/scala/docs/http/scaladsl/server/directives/JsonStreamingExamplesSpec.scala) { #csv-example }

Java
:   @@snip [JsonStreamingExamplesTest.java]($test$/java/docs/http/javadsl/server/JsonStreamingExamplesTest.java) { #csv-example }

## Implementing custom EntityStreamingSupport traits
## 实现自定义 EntityStreamingSupport trait

The @apidoc[EntityStreamingSupport] infrastructure is open for extension and not bound to any single format, content type,
or marshalling library. The provided JSON support does not rely on `spray-json` directly, but uses @apidoc[Marshaller[T, ByteString]]
instances, which can be provided using any JSON marshalling library (such as Circe, Jawn or Play JSON).

@apidoc[EntityStreamingSupport] 基础设施对扩展是开放的并且不绑定的任何单一格式：内容类型或编组库。
提供 JSON 支持并不直接依赖 `spary-json`，而是使用 @apidoc[Marshaller[T, ByteString]] 实例，可以使用任何 JSON 编组库（如：Circe、Jawn 或 Play JSON）提供该实例。

When implementing a custom support trait, one should simply extend the @apidoc[EntityStreamingSupport] abstract class
and implement all of its methods. It's best to use the existing implementations as a guideline.

当实现自定义支持 trait 时，只用扩展 @apidoc[EntityStreamingSupport] 抽象类并实现所有方法。最好使用现有实现作为指导原则。

## Supporting custom content types
**支持自定义内容类型**

In order to marshal into custom content types, both a @apidoc[Marshaller] that can handle that content type
**as well as an @apidoc[EntityStreamingSupport] of matching content type** is required.

为了编组到自定义内容类型，既需要一个 @apidoc[Marshaller] 可以处理该内容类型， **也需要一个匹配内容类型的 @apidoc[EntityStreamingSupport]** 。 

Refer to the complete example below, showcasing how to configure a custom marshaller and change
the entity streaming support's content type to be compatible. This is an area that would benefit from additional type safety,
which we hope to add in a future release.

参考下面的完整示例，展示如何配置一个自定义编组并将实体流更改为兼容支持的内容类型。这是一个可以从额外的类型安全上获益的领域，我们希望在未来的发布中添加它。

Scala
:   @@snip [JsonStreamingFullExamples.scala]($test$/scala/docs/http/scaladsl/server/directives/JsonStreamingFullExamples.scala) { #custom-content-type }

Java
:   @@snip [JsonStreamingFullExample.java]($test$/java/docs/http/javadsl/server/directives/JsonStreamingFullExample.java) { #custom-content-type }

## Consuming streaming JSON on client-side
**在客户端消费流式 JSON**

For consuming such streaming APIs with, for example, JSON responses refer to @ref[Consuming JSON Streaming style APIs](../common/json-support.md#consuming-json-streaming-style-apis)
documentation in the JSON support section.

例如，消费此类流式 API 的 JSON 响应，参考在 JSON 支持部分的 @ref[消费 JSON 流式风格的 APIs](../common/json-support.md#consuming-json-streaming-style-apis) 文档。
